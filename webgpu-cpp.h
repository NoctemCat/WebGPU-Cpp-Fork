/**
 * This file is part of the "Learn WebGPU for C++" book.
 *   https://github.com/eliemichel/LearnWebGPU
 *
 * MIT License
 * Copyright (c) 2022 Elie Michel
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * Exactly one of your source files must #define WEBGPU_CPP_IMPLEMENTATION
 * before including this header.
 * 
 * NB: This file has been generated by the webgpu-cpp generator
 *   (see https://github.com/eliemichel/webgpu-cpp )
 */

#pragma once

#ifndef WEBGPU_H_
#error "You must include the WEBGPU header before this one"
#endif

#include "webgpu-utils.h"
#include <iostream>

/**
 * A namespace providing a more C++ idiomatic API to WebGPU.
 */
namespace wgpu {

#define HANDLE(Type) \
class Type { \
public: \
	typedef Type S; /* S == Self */ \
    typedef WGPU ## Type W; /* W == WGPU Type */ \
	Type(const W& w) : m_raw(w) {} \
	operator W() { return m_raw; } \
	operator bool() const { return m_raw != nullptr; } \
	friend auto operator<<(std::ostream &stream, const S& self) -> std::ostream & { \
		return stream << "<wgpu::" << #Type << " " << self.m_raw << ">"; \
	} \
private: \
	W m_raw; \
public:

#define DESCRIPTOR(Type) \
struct Type : public WGPU ## Type { \
public: \
	typedef Type S; /* S == Self */ \
    typedef WGPU ## Type W; /* W == WGPU Type */ \
	Type() : W() { nextInChain = nullptr; } \
	friend auto operator<<(std::ostream &stream, const S&) -> std::ostream & { \
		return stream << "<wgpu::" << #Type << ">"; \
	} \
public:

#define END };

// Enumerations
typedef WGPUTextureFormat TextureFormat;

// Descriptors
DESCRIPTOR(AdapterProperties)
END

DESCRIPTOR(BindGroupEntry)
END

DESCRIPTOR(BufferBindingLayout)
END

DESCRIPTOR(BufferDescriptor)
END

DESCRIPTOR(CommandBufferDescriptor)
END

DESCRIPTOR(CommandEncoderDescriptor)
END

DESCRIPTOR(CompilationMessage)
END

DESCRIPTOR(ConstantEntry)
END

DESCRIPTOR(InstanceDescriptor)
END

DESCRIPTOR(MultisampleState)
END

DESCRIPTOR(PipelineLayoutDescriptor)
END

DESCRIPTOR(PrimitiveState)
END

DESCRIPTOR(QuerySetDescriptor)
END

DESCRIPTOR(QueueDescriptor)
END

DESCRIPTOR(RenderBundleDescriptor)
END

DESCRIPTOR(RenderBundleEncoderDescriptor)
END

DESCRIPTOR(RequestAdapterOptions)
END

DESCRIPTOR(SamplerBindingLayout)
END

DESCRIPTOR(SamplerDescriptor)
END

DESCRIPTOR(ShaderModuleCompilationHint)
END

DESCRIPTOR(StorageTextureBindingLayout)
END

DESCRIPTOR(SurfaceDescriptor)
END

DESCRIPTOR(SwapChainDescriptor)
END

DESCRIPTOR(TextureBindingLayout)
END

DESCRIPTOR(TextureDataLayout)
END

DESCRIPTOR(TextureViewDescriptor)
END

DESCRIPTOR(BindGroupDescriptor)
END

DESCRIPTOR(BindGroupLayoutEntry)
END

DESCRIPTOR(CompilationInfo)
END

DESCRIPTOR(ComputePassDescriptor)
END

DESCRIPTOR(DepthStencilState)
END

DESCRIPTOR(ImageCopyBuffer)
END

DESCRIPTOR(ImageCopyTexture)
END

DESCRIPTOR(ProgrammableStageDescriptor)
END

DESCRIPTOR(RequiredLimits)
END

DESCRIPTOR(ShaderModuleDescriptor)
END

DESCRIPTOR(SupportedLimits)
END

DESCRIPTOR(TextureDescriptor)
END

DESCRIPTOR(BindGroupLayoutDescriptor)
END

DESCRIPTOR(ColorTargetState)
END

DESCRIPTOR(ComputePipelineDescriptor)
END

DESCRIPTOR(DeviceDescriptor)
END

DESCRIPTOR(RenderPassDescriptor)
END

DESCRIPTOR(VertexState)
END

DESCRIPTOR(FragmentState)
END

DESCRIPTOR(RenderPipelineDescriptor)
END


// Handles forward declarations
class Adapter;
class BindGroup;
class BindGroupLayout;
class Buffer;
class CommandBuffer;
class CommandEncoder;
class ComputePassEncoder;
class ComputePipeline;
class Device;
class Instance;
class PipelineLayout;
class QuerySet;
class Queue;
class RenderBundle;
class RenderBundleEncoder;
class RenderPassEncoder;
class RenderPipeline;
class Sampler;
class ShaderModule;
class Surface;
class SwapChain;
class Texture;
class TextureView;

// Handles detailed declarations
HANDLE(Adapter)
  size_t enumerateFeatures(FeatureName * features);
  bool getLimits(SupportedLimits * limits);
  void getProperties(AdapterProperties * properties);
  bool hasFeature(FeatureName feature);
  void requestDevice(DeviceDescriptor const * descriptor = nullptr, RequestDeviceCallback callback, void * userdata);
END

HANDLE(BindGroup)
  void setLabel(char const * label);
  void layoutSetLabel(char const * label);
END

HANDLE(BindGroupLayout)
  void setLabel(char const * label);
END

HANDLE(Buffer)
  void destroy();
  uint64_t getSize();
  BufferUsage getUsage();
  void mapAsync(MapModeFlags mode, size_t offset, size_t size, BufferMapCallback callback, void * userdata);
  void setLabel(char const * label);
  void unmap();
END

HANDLE(CommandBuffer)
  void setLabel(char const * label);
END

HANDLE(CommandEncoder)
  ComputePassEncoder beginComputePass(ComputePassDescriptor const * descriptor = nullptr);
  RenderPassEncoder beginRenderPass(RenderPassDescriptor const * descriptor);
  void clearBuffer(const Buffer& buffer, uint64_t offset, uint64_t size);
  void copyBufferToBuffer(const Buffer& source, uint64_t sourceOffset, const Buffer& destination, uint64_t destinationOffset, uint64_t size);
  void copyBufferToTexture(ImageCopyBuffer const * source, ImageCopyTexture const * destination, Extent3D const * copySize);
  void copyTextureToBuffer(ImageCopyTexture const * source, ImageCopyBuffer const * destination, Extent3D const * copySize);
  void copyTextureToTexture(ImageCopyTexture const * source, ImageCopyTexture const * destination, Extent3D const * copySize);
  CommandBuffer finish(CommandBufferDescriptor const * descriptor = nullptr);
  void insertDebugMarker(char const * markerLabel);
  void popDebugGroup();
  void pushDebugGroup(char const * groupLabel);
  void resolveQuerySet(const QuerySet& querySet, uint32_t firstQuery, uint32_t queryCount, const Buffer& destination, uint64_t destinationOffset);
  void setLabel(char const * label);
  void writeTimestamp(const QuerySet& querySet, uint32_t queryIndex);
END

HANDLE(ComputePassEncoder)
  void beginPipelineStatisticsQuery(const QuerySet& querySet, uint32_t queryIndex);
  void dispatchWorkgroups(uint32_t workgroupCountX, uint32_t workgroupCountY, uint32_t workgroupCountZ);
  void dispatchWorkgroupsIndirect(const Buffer& indirectBuffer, uint64_t indirectOffset);
  void end();
  void endPipelineStatisticsQuery();
  void insertDebugMarker(char const * markerLabel);
  void popDebugGroup();
  void pushDebugGroup(char const * groupLabel);
  void setBindGroup(uint32_t groupIndex, const BindGroup& group, uint32_t dynamicOffsetCount, uint32_t const * dynamicOffsets);
  void setLabel(char const * label);
  void setPipeline(const ComputePipeline& pipeline);
END

HANDLE(ComputePipeline)
  BindGroupLayout getBindGroupLayout(uint32_t groupIndex);
  void setLabel(char const * label);
END

HANDLE(Device)
  BindGroup createBindGroup(BindGroupDescriptor const * descriptor);
  BindGroupLayout createBindGroupLayout(BindGroupLayoutDescriptor const * descriptor);
  Buffer createBuffer(BufferDescriptor const * descriptor);
  CommandEncoder createCommandEncoder(CommandEncoderDescriptor const * descriptor = nullptr);
  ComputePipeline createComputePipeline(ComputePipelineDescriptor const * descriptor);
  void createComputePipelineAsync(ComputePipelineDescriptor const * descriptor, CreateComputePipelineAsyncCallback callback, void * userdata);
  PipelineLayout createPipelineLayout(PipelineLayoutDescriptor const * descriptor);
  QuerySet createQuerySet(QuerySetDescriptor const * descriptor);
  RenderBundleEncoder createRenderBundleEncoder(RenderBundleEncoderDescriptor const * descriptor);
  RenderPipeline createRenderPipeline(RenderPipelineDescriptor const * descriptor);
  void createRenderPipelineAsync(RenderPipelineDescriptor const * descriptor, CreateRenderPipelineAsyncCallback callback, void * userdata);
  Sampler createSampler(SamplerDescriptor const * descriptor = nullptr);
  ShaderModule createShaderModule(ShaderModuleDescriptor const * descriptor);
  SwapChain createSwapChain(const Surface& surface, SwapChainDescriptor const * descriptor);
  Texture createTexture(TextureDescriptor const * descriptor);
  void destroy();
  size_t enumerateFeatures(FeatureName * features);
  bool getLimits(SupportedLimits * limits);
  Queue getQueue();
  bool hasFeature(FeatureName feature);
  bool popErrorScope(ErrorCallback callback, void * userdata);
  void pushErrorScope(ErrorFilter filter);
  void setDeviceLostCallback(DeviceLostCallback callback, void * userdata);
  void setLabel(char const * label);
  void setUncapturedErrorCallback(ErrorCallback callback, void * userdata);
END

HANDLE(Instance)
  Surface createSurface(SurfaceDescriptor const * descriptor);
  void processEvents();
  void requestAdapter(RequestAdapterOptions const * options = nullptr, RequestAdapterCallback callback, void * userdata);
END

HANDLE(PipelineLayout)
  void setLabel(char const * label);
END

HANDLE(QuerySet)
  void destroy();
  uint32_t getCount();
  QueryType getType();
  void setLabel(char const * label);
END

HANDLE(Queue)
  void onSubmittedWorkDone(QueueWorkDoneCallback callback, void * userdata);
  void setLabel(char const * label);
  void submit(uint32_t commandCount, CommandBuffer const * commands);
  void writeBuffer(const Buffer& buffer, uint64_t bufferOffset, void const * data, size_t size);
  void writeTexture(ImageCopyTexture const * destination, void const * data, size_t dataSize, TextureDataLayout const * dataLayout, Extent3D const * writeSize);
END

HANDLE(RenderBundle)
  void encoderDraw(uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance);
  void encoderDrawIndexed(uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t baseVertex, uint32_t firstInstance);
  void encoderDrawIndexedIndirect(const Buffer& indirectBuffer, uint64_t indirectOffset);
  void encoderDrawIndirect(const Buffer& indirectBuffer, uint64_t indirectOffset);
  RenderBundle encoderFinish(RenderBundleDescriptor const * descriptor = nullptr);
  void encoderInsertDebugMarker(char const * markerLabel);
  void encoderPopDebugGroup();
  void encoderPushDebugGroup(char const * groupLabel);
  void encoderSetBindGroup(uint32_t groupIndex, const BindGroup& group, uint32_t dynamicOffsetCount, uint32_t const * dynamicOffsets);
  void encoderSetIndexBuffer(const Buffer& buffer, IndexFormat format, uint64_t offset, uint64_t size);
  void encoderSetLabel(char const * label);
  void encoderSetPipeline(const RenderPipeline& pipeline);
  void encoderSetVertexBuffer(uint32_t slot, const Buffer& buffer, uint64_t offset, uint64_t size);
END

HANDLE(RenderBundleEncoder)
  void draw(uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance);
  void drawIndexed(uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t baseVertex, uint32_t firstInstance);
  void drawIndexedIndirect(const Buffer& indirectBuffer, uint64_t indirectOffset);
  void drawIndirect(const Buffer& indirectBuffer, uint64_t indirectOffset);
  RenderBundle finish(RenderBundleDescriptor const * descriptor = nullptr);
  void insertDebugMarker(char const * markerLabel);
  void popDebugGroup();
  void pushDebugGroup(char const * groupLabel);
  void setBindGroup(uint32_t groupIndex, const BindGroup& group, uint32_t dynamicOffsetCount, uint32_t const * dynamicOffsets);
  void setIndexBuffer(const Buffer& buffer, IndexFormat format, uint64_t offset, uint64_t size);
  void setLabel(char const * label);
  void setPipeline(const RenderPipeline& pipeline);
  void setVertexBuffer(uint32_t slot, const Buffer& buffer, uint64_t offset, uint64_t size);
END

HANDLE(RenderPassEncoder)
  void beginOcclusionQuery(uint32_t queryIndex);
  void beginPipelineStatisticsQuery(const QuerySet& querySet, uint32_t queryIndex);
  void draw(uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance);
  void drawIndexed(uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t baseVertex, uint32_t firstInstance);
  void drawIndexedIndirect(const Buffer& indirectBuffer, uint64_t indirectOffset);
  void drawIndirect(const Buffer& indirectBuffer, uint64_t indirectOffset);
  void end();
  void endOcclusionQuery();
  void endPipelineStatisticsQuery();
  void executeBundles(uint32_t bundlesCount, RenderBundle const * bundles);
  void insertDebugMarker(char const * markerLabel);
  void popDebugGroup();
  void pushDebugGroup(char const * groupLabel);
  void setBindGroup(uint32_t groupIndex, const BindGroup& group, uint32_t dynamicOffsetCount, uint32_t const * dynamicOffsets);
  void setBlendConstant(Color const * color);
  void setIndexBuffer(const Buffer& buffer, IndexFormat format, uint64_t offset, uint64_t size);
  void setLabel(char const * label);
  void setPipeline(const RenderPipeline& pipeline);
  void setScissorRect(uint32_t x, uint32_t y, uint32_t width, uint32_t height);
  void setStencilReference(uint32_t reference);
  void setVertexBuffer(uint32_t slot, const Buffer& buffer, uint64_t offset, uint64_t size);
  void setViewport(float x, float y, float width, float height, float minDepth, float maxDepth);
END

HANDLE(RenderPipeline)
  BindGroupLayout getBindGroupLayout(uint32_t groupIndex);
  void setLabel(char const * label);
END

HANDLE(Sampler)
  void setLabel(char const * label);
END

HANDLE(ShaderModule)
  void getCompilationInfo(CompilationInfoCallback callback, void * userdata);
  void setLabel(char const * label);
END

HANDLE(Surface)
  TextureFormat getPreferredFormat(const Adapter& adapter);
END

HANDLE(SwapChain)
  TextureView getCurrentTextureView();
  void present();
END

HANDLE(Texture)
  TextureView createView(TextureViewDescriptor const * descriptor = nullptr);
  void destroy();
  uint32_t getDepthOrArrayLayers();
  TextureDimension getDimension();
  TextureFormat getFormat();
  uint32_t getHeight();
  uint32_t getMipLevelCount();
  uint32_t getSampleCount();
  TextureUsage getUsage();
  uint32_t getWidth();
  void setLabel(char const * label);
  void viewSetLabel(char const * label);
END

HANDLE(TextureView)
  void setLabel(char const * label);
END


Instance createInstance(const InstanceDescriptor& descriptor) {
    return wgpuCreateInstance(&descriptor);
}

#ifdef WEBGPU_CPP_IMPLEMENTATION

// Handles members implementation
// Methods of Adapter
size_t Adapter::enumerateFeatures(FeatureName * features) {
  return wgpuAdapterEnumerateFeatures(m_raw, features);
}
bool Adapter::getLimits(SupportedLimits * limits) {
  return wgpuAdapterGetLimits(m_raw, limits);
}
void Adapter::getProperties(AdapterProperties * properties) {
  return wgpuAdapterGetProperties(m_raw, properties);
}
bool Adapter::hasFeature(FeatureName feature) {
  return wgpuAdapterHasFeature(m_raw, feature);
}
void Adapter::requestDevice(DeviceDescriptor const * descriptor = nullptr, RequestDeviceCallback callback, void * userdata) {
  return wgpuAdapterRequestDevice(m_raw, descriptor, callback, userdata);
}


// Methods of BindGroup
void BindGroup::setLabel(char const * label) {
  return wgpuBindGroupSetLabel(m_raw, label);
}
void BindGroup::layoutSetLabel(char const * label) {
  return wgpuBindGroupLayoutSetLabel(m_raw, label);
}


// Methods of BindGroupLayout
void BindGroupLayout::setLabel(char const * label) {
  return wgpuBindGroupLayoutSetLabel(m_raw, label);
}


// Methods of Buffer
void Buffer::destroy() {
  return wgpuBufferDestroy(m_raw, );
}
uint64_t Buffer::getSize() {
  return wgpuBufferGetSize(m_raw, );
}
BufferUsage Buffer::getUsage() {
  return wgpuBufferGetUsage(m_raw, );
}
void Buffer::mapAsync(MapModeFlags mode, size_t offset, size_t size, BufferMapCallback callback, void * userdata) {
  return wgpuBufferMapAsync(m_raw, mode, offset, size, callback, userdata);
}
void Buffer::setLabel(char const * label) {
  return wgpuBufferSetLabel(m_raw, label);
}
void Buffer::unmap() {
  return wgpuBufferUnmap(m_raw, );
}


// Methods of CommandBuffer
void CommandBuffer::setLabel(char const * label) {
  return wgpuCommandBufferSetLabel(m_raw, label);
}


// Methods of CommandEncoder
ComputePassEncoder CommandEncoder::beginComputePass(ComputePassDescriptor const * descriptor = nullptr) {
  return wgpuCommandEncoderBeginComputePass(m_raw, descriptor);
}
RenderPassEncoder CommandEncoder::beginRenderPass(RenderPassDescriptor const * descriptor) {
  return wgpuCommandEncoderBeginRenderPass(m_raw, descriptor);
}
void CommandEncoder::clearBuffer(const Buffer& buffer, uint64_t offset, uint64_t size) {
  return wgpuCommandEncoderClearBuffer(m_raw, buffer, offset, size);
}
void CommandEncoder::copyBufferToBuffer(const Buffer& source, uint64_t sourceOffset, const Buffer& destination, uint64_t destinationOffset, uint64_t size) {
  return wgpuCommandEncoderCopyBufferToBuffer(m_raw, source, sourceOffset, destination, destinationOffset, size);
}
void CommandEncoder::copyBufferToTexture(ImageCopyBuffer const * source, ImageCopyTexture const * destination, Extent3D const * copySize) {
  return wgpuCommandEncoderCopyBufferToTexture(m_raw, source, destination, copySize);
}
void CommandEncoder::copyTextureToBuffer(ImageCopyTexture const * source, ImageCopyBuffer const * destination, Extent3D const * copySize) {
  return wgpuCommandEncoderCopyTextureToBuffer(m_raw, source, destination, copySize);
}
void CommandEncoder::copyTextureToTexture(ImageCopyTexture const * source, ImageCopyTexture const * destination, Extent3D const * copySize) {
  return wgpuCommandEncoderCopyTextureToTexture(m_raw, source, destination, copySize);
}
CommandBuffer CommandEncoder::finish(CommandBufferDescriptor const * descriptor = nullptr) {
  return wgpuCommandEncoderFinish(m_raw, descriptor);
}
void CommandEncoder::insertDebugMarker(char const * markerLabel) {
  return wgpuCommandEncoderInsertDebugMarker(m_raw, markerLabel);
}
void CommandEncoder::popDebugGroup() {
  return wgpuCommandEncoderPopDebugGroup(m_raw, );
}
void CommandEncoder::pushDebugGroup(char const * groupLabel) {
  return wgpuCommandEncoderPushDebugGroup(m_raw, groupLabel);
}
void CommandEncoder::resolveQuerySet(const QuerySet& querySet, uint32_t firstQuery, uint32_t queryCount, const Buffer& destination, uint64_t destinationOffset) {
  return wgpuCommandEncoderResolveQuerySet(m_raw, querySet, firstQuery, queryCount, destination, destinationOffset);
}
void CommandEncoder::setLabel(char const * label) {
  return wgpuCommandEncoderSetLabel(m_raw, label);
}
void CommandEncoder::writeTimestamp(const QuerySet& querySet, uint32_t queryIndex) {
  return wgpuCommandEncoderWriteTimestamp(m_raw, querySet, queryIndex);
}


// Methods of ComputePassEncoder
void ComputePassEncoder::beginPipelineStatisticsQuery(const QuerySet& querySet, uint32_t queryIndex) {
  return wgpuComputePassEncoderBeginPipelineStatisticsQuery(m_raw, querySet, queryIndex);
}
void ComputePassEncoder::dispatchWorkgroups(uint32_t workgroupCountX, uint32_t workgroupCountY, uint32_t workgroupCountZ) {
  return wgpuComputePassEncoderDispatchWorkgroups(m_raw, workgroupCountX, workgroupCountY, workgroupCountZ);
}
void ComputePassEncoder::dispatchWorkgroupsIndirect(const Buffer& indirectBuffer, uint64_t indirectOffset) {
  return wgpuComputePassEncoderDispatchWorkgroupsIndirect(m_raw, indirectBuffer, indirectOffset);
}
void ComputePassEncoder::end() {
  return wgpuComputePassEncoderEnd(m_raw, );
}
void ComputePassEncoder::endPipelineStatisticsQuery() {
  return wgpuComputePassEncoderEndPipelineStatisticsQuery(m_raw, );
}
void ComputePassEncoder::insertDebugMarker(char const * markerLabel) {
  return wgpuComputePassEncoderInsertDebugMarker(m_raw, markerLabel);
}
void ComputePassEncoder::popDebugGroup() {
  return wgpuComputePassEncoderPopDebugGroup(m_raw, );
}
void ComputePassEncoder::pushDebugGroup(char const * groupLabel) {
  return wgpuComputePassEncoderPushDebugGroup(m_raw, groupLabel);
}
void ComputePassEncoder::setBindGroup(uint32_t groupIndex, const BindGroup& group, uint32_t dynamicOffsetCount, uint32_t const * dynamicOffsets) {
  return wgpuComputePassEncoderSetBindGroup(m_raw, groupIndex, group, dynamicOffsetCount, dynamicOffsets);
}
void ComputePassEncoder::setLabel(char const * label) {
  return wgpuComputePassEncoderSetLabel(m_raw, label);
}
void ComputePassEncoder::setPipeline(const ComputePipeline& pipeline) {
  return wgpuComputePassEncoderSetPipeline(m_raw, pipeline);
}


// Methods of ComputePipeline
BindGroupLayout ComputePipeline::getBindGroupLayout(uint32_t groupIndex) {
  return wgpuComputePipelineGetBindGroupLayout(m_raw, groupIndex);
}
void ComputePipeline::setLabel(char const * label) {
  return wgpuComputePipelineSetLabel(m_raw, label);
}


// Methods of Device
BindGroup Device::createBindGroup(BindGroupDescriptor const * descriptor) {
  return wgpuDeviceCreateBindGroup(m_raw, descriptor);
}
BindGroupLayout Device::createBindGroupLayout(BindGroupLayoutDescriptor const * descriptor) {
  return wgpuDeviceCreateBindGroupLayout(m_raw, descriptor);
}
Buffer Device::createBuffer(BufferDescriptor const * descriptor) {
  return wgpuDeviceCreateBuffer(m_raw, descriptor);
}
CommandEncoder Device::createCommandEncoder(CommandEncoderDescriptor const * descriptor = nullptr) {
  return wgpuDeviceCreateCommandEncoder(m_raw, descriptor);
}
ComputePipeline Device::createComputePipeline(ComputePipelineDescriptor const * descriptor) {
  return wgpuDeviceCreateComputePipeline(m_raw, descriptor);
}
void Device::createComputePipelineAsync(ComputePipelineDescriptor const * descriptor, CreateComputePipelineAsyncCallback callback, void * userdata) {
  return wgpuDeviceCreateComputePipelineAsync(m_raw, descriptor, callback, userdata);
}
PipelineLayout Device::createPipelineLayout(PipelineLayoutDescriptor const * descriptor) {
  return wgpuDeviceCreatePipelineLayout(m_raw, descriptor);
}
QuerySet Device::createQuerySet(QuerySetDescriptor const * descriptor) {
  return wgpuDeviceCreateQuerySet(m_raw, descriptor);
}
RenderBundleEncoder Device::createRenderBundleEncoder(RenderBundleEncoderDescriptor const * descriptor) {
  return wgpuDeviceCreateRenderBundleEncoder(m_raw, descriptor);
}
RenderPipeline Device::createRenderPipeline(RenderPipelineDescriptor const * descriptor) {
  return wgpuDeviceCreateRenderPipeline(m_raw, descriptor);
}
void Device::createRenderPipelineAsync(RenderPipelineDescriptor const * descriptor, CreateRenderPipelineAsyncCallback callback, void * userdata) {
  return wgpuDeviceCreateRenderPipelineAsync(m_raw, descriptor, callback, userdata);
}
Sampler Device::createSampler(SamplerDescriptor const * descriptor = nullptr) {
  return wgpuDeviceCreateSampler(m_raw, descriptor);
}
ShaderModule Device::createShaderModule(ShaderModuleDescriptor const * descriptor) {
  return wgpuDeviceCreateShaderModule(m_raw, descriptor);
}
SwapChain Device::createSwapChain(const Surface& surface, SwapChainDescriptor const * descriptor) {
  return wgpuDeviceCreateSwapChain(m_raw, surface, descriptor);
}
Texture Device::createTexture(TextureDescriptor const * descriptor) {
  return wgpuDeviceCreateTexture(m_raw, descriptor);
}
void Device::destroy() {
  return wgpuDeviceDestroy(m_raw, );
}
size_t Device::enumerateFeatures(FeatureName * features) {
  return wgpuDeviceEnumerateFeatures(m_raw, features);
}
bool Device::getLimits(SupportedLimits * limits) {
  return wgpuDeviceGetLimits(m_raw, limits);
}
Queue Device::getQueue() {
  return wgpuDeviceGetQueue(m_raw, );
}
bool Device::hasFeature(FeatureName feature) {
  return wgpuDeviceHasFeature(m_raw, feature);
}
bool Device::popErrorScope(ErrorCallback callback, void * userdata) {
  return wgpuDevicePopErrorScope(m_raw, callback, userdata);
}
void Device::pushErrorScope(ErrorFilter filter) {
  return wgpuDevicePushErrorScope(m_raw, filter);
}
void Device::setDeviceLostCallback(DeviceLostCallback callback, void * userdata) {
  return wgpuDeviceSetDeviceLostCallback(m_raw, callback, userdata);
}
void Device::setLabel(char const * label) {
  return wgpuDeviceSetLabel(m_raw, label);
}
void Device::setUncapturedErrorCallback(ErrorCallback callback, void * userdata) {
  return wgpuDeviceSetUncapturedErrorCallback(m_raw, callback, userdata);
}


// Methods of Instance
Surface Instance::createSurface(SurfaceDescriptor const * descriptor) {
  return wgpuInstanceCreateSurface(m_raw, descriptor);
}
void Instance::processEvents() {
  return wgpuInstanceProcessEvents(m_raw, );
}
void Instance::requestAdapter(RequestAdapterOptions const * options = nullptr, RequestAdapterCallback callback, void * userdata) {
  return wgpuInstanceRequestAdapter(m_raw, options, callback, userdata);
}


// Methods of PipelineLayout
void PipelineLayout::setLabel(char const * label) {
  return wgpuPipelineLayoutSetLabel(m_raw, label);
}


// Methods of QuerySet
void QuerySet::destroy() {
  return wgpuQuerySetDestroy(m_raw, );
}
uint32_t QuerySet::getCount() {
  return wgpuQuerySetGetCount(m_raw, );
}
QueryType QuerySet::getType() {
  return wgpuQuerySetGetType(m_raw, );
}
void QuerySet::setLabel(char const * label) {
  return wgpuQuerySetSetLabel(m_raw, label);
}


// Methods of Queue
void Queue::onSubmittedWorkDone(QueueWorkDoneCallback callback, void * userdata) {
  return wgpuQueueOnSubmittedWorkDone(m_raw, callback, userdata);
}
void Queue::setLabel(char const * label) {
  return wgpuQueueSetLabel(m_raw, label);
}
void Queue::submit(uint32_t commandCount, CommandBuffer const * commands) {
  return wgpuQueueSubmit(m_raw, commandCount, commands);
}
void Queue::writeBuffer(const Buffer& buffer, uint64_t bufferOffset, void const * data, size_t size) {
  return wgpuQueueWriteBuffer(m_raw, buffer, bufferOffset, data, size);
}
void Queue::writeTexture(ImageCopyTexture const * destination, void const * data, size_t dataSize, TextureDataLayout const * dataLayout, Extent3D const * writeSize) {
  return wgpuQueueWriteTexture(m_raw, destination, data, dataSize, dataLayout, writeSize);
}


// Methods of RenderBundle
void RenderBundle::encoderDraw(uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) {
  return wgpuRenderBundleEncoderDraw(m_raw, vertexCount, instanceCount, firstVertex, firstInstance);
}
void RenderBundle::encoderDrawIndexed(uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t baseVertex, uint32_t firstInstance) {
  return wgpuRenderBundleEncoderDrawIndexed(m_raw, indexCount, instanceCount, firstIndex, baseVertex, firstInstance);
}
void RenderBundle::encoderDrawIndexedIndirect(const Buffer& indirectBuffer, uint64_t indirectOffset) {
  return wgpuRenderBundleEncoderDrawIndexedIndirect(m_raw, indirectBuffer, indirectOffset);
}
void RenderBundle::encoderDrawIndirect(const Buffer& indirectBuffer, uint64_t indirectOffset) {
  return wgpuRenderBundleEncoderDrawIndirect(m_raw, indirectBuffer, indirectOffset);
}
RenderBundle RenderBundle::encoderFinish(RenderBundleDescriptor const * descriptor = nullptr) {
  return wgpuRenderBundleEncoderFinish(m_raw, descriptor);
}
void RenderBundle::encoderInsertDebugMarker(char const * markerLabel) {
  return wgpuRenderBundleEncoderInsertDebugMarker(m_raw, markerLabel);
}
void RenderBundle::encoderPopDebugGroup() {
  return wgpuRenderBundleEncoderPopDebugGroup(m_raw, );
}
void RenderBundle::encoderPushDebugGroup(char const * groupLabel) {
  return wgpuRenderBundleEncoderPushDebugGroup(m_raw, groupLabel);
}
void RenderBundle::encoderSetBindGroup(uint32_t groupIndex, const BindGroup& group, uint32_t dynamicOffsetCount, uint32_t const * dynamicOffsets) {
  return wgpuRenderBundleEncoderSetBindGroup(m_raw, groupIndex, group, dynamicOffsetCount, dynamicOffsets);
}
void RenderBundle::encoderSetIndexBuffer(const Buffer& buffer, IndexFormat format, uint64_t offset, uint64_t size) {
  return wgpuRenderBundleEncoderSetIndexBuffer(m_raw, buffer, format, offset, size);
}
void RenderBundle::encoderSetLabel(char const * label) {
  return wgpuRenderBundleEncoderSetLabel(m_raw, label);
}
void RenderBundle::encoderSetPipeline(const RenderPipeline& pipeline) {
  return wgpuRenderBundleEncoderSetPipeline(m_raw, pipeline);
}
void RenderBundle::encoderSetVertexBuffer(uint32_t slot, const Buffer& buffer, uint64_t offset, uint64_t size) {
  return wgpuRenderBundleEncoderSetVertexBuffer(m_raw, slot, buffer, offset, size);
}


// Methods of RenderBundleEncoder
void RenderBundleEncoder::draw(uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) {
  return wgpuRenderBundleEncoderDraw(m_raw, vertexCount, instanceCount, firstVertex, firstInstance);
}
void RenderBundleEncoder::drawIndexed(uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t baseVertex, uint32_t firstInstance) {
  return wgpuRenderBundleEncoderDrawIndexed(m_raw, indexCount, instanceCount, firstIndex, baseVertex, firstInstance);
}
void RenderBundleEncoder::drawIndexedIndirect(const Buffer& indirectBuffer, uint64_t indirectOffset) {
  return wgpuRenderBundleEncoderDrawIndexedIndirect(m_raw, indirectBuffer, indirectOffset);
}
void RenderBundleEncoder::drawIndirect(const Buffer& indirectBuffer, uint64_t indirectOffset) {
  return wgpuRenderBundleEncoderDrawIndirect(m_raw, indirectBuffer, indirectOffset);
}
RenderBundle RenderBundleEncoder::finish(RenderBundleDescriptor const * descriptor = nullptr) {
  return wgpuRenderBundleEncoderFinish(m_raw, descriptor);
}
void RenderBundleEncoder::insertDebugMarker(char const * markerLabel) {
  return wgpuRenderBundleEncoderInsertDebugMarker(m_raw, markerLabel);
}
void RenderBundleEncoder::popDebugGroup() {
  return wgpuRenderBundleEncoderPopDebugGroup(m_raw, );
}
void RenderBundleEncoder::pushDebugGroup(char const * groupLabel) {
  return wgpuRenderBundleEncoderPushDebugGroup(m_raw, groupLabel);
}
void RenderBundleEncoder::setBindGroup(uint32_t groupIndex, const BindGroup& group, uint32_t dynamicOffsetCount, uint32_t const * dynamicOffsets) {
  return wgpuRenderBundleEncoderSetBindGroup(m_raw, groupIndex, group, dynamicOffsetCount, dynamicOffsets);
}
void RenderBundleEncoder::setIndexBuffer(const Buffer& buffer, IndexFormat format, uint64_t offset, uint64_t size) {
  return wgpuRenderBundleEncoderSetIndexBuffer(m_raw, buffer, format, offset, size);
}
void RenderBundleEncoder::setLabel(char const * label) {
  return wgpuRenderBundleEncoderSetLabel(m_raw, label);
}
void RenderBundleEncoder::setPipeline(const RenderPipeline& pipeline) {
  return wgpuRenderBundleEncoderSetPipeline(m_raw, pipeline);
}
void RenderBundleEncoder::setVertexBuffer(uint32_t slot, const Buffer& buffer, uint64_t offset, uint64_t size) {
  return wgpuRenderBundleEncoderSetVertexBuffer(m_raw, slot, buffer, offset, size);
}


// Methods of RenderPassEncoder
void RenderPassEncoder::beginOcclusionQuery(uint32_t queryIndex) {
  return wgpuRenderPassEncoderBeginOcclusionQuery(m_raw, queryIndex);
}
void RenderPassEncoder::beginPipelineStatisticsQuery(const QuerySet& querySet, uint32_t queryIndex) {
  return wgpuRenderPassEncoderBeginPipelineStatisticsQuery(m_raw, querySet, queryIndex);
}
void RenderPassEncoder::draw(uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) {
  return wgpuRenderPassEncoderDraw(m_raw, vertexCount, instanceCount, firstVertex, firstInstance);
}
void RenderPassEncoder::drawIndexed(uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t baseVertex, uint32_t firstInstance) {
  return wgpuRenderPassEncoderDrawIndexed(m_raw, indexCount, instanceCount, firstIndex, baseVertex, firstInstance);
}
void RenderPassEncoder::drawIndexedIndirect(const Buffer& indirectBuffer, uint64_t indirectOffset) {
  return wgpuRenderPassEncoderDrawIndexedIndirect(m_raw, indirectBuffer, indirectOffset);
}
void RenderPassEncoder::drawIndirect(const Buffer& indirectBuffer, uint64_t indirectOffset) {
  return wgpuRenderPassEncoderDrawIndirect(m_raw, indirectBuffer, indirectOffset);
}
void RenderPassEncoder::end() {
  return wgpuRenderPassEncoderEnd(m_raw, );
}
void RenderPassEncoder::endOcclusionQuery() {
  return wgpuRenderPassEncoderEndOcclusionQuery(m_raw, );
}
void RenderPassEncoder::endPipelineStatisticsQuery() {
  return wgpuRenderPassEncoderEndPipelineStatisticsQuery(m_raw, );
}
void RenderPassEncoder::executeBundles(uint32_t bundlesCount, RenderBundle const * bundles) {
  return wgpuRenderPassEncoderExecuteBundles(m_raw, bundlesCount, bundles);
}
void RenderPassEncoder::insertDebugMarker(char const * markerLabel) {
  return wgpuRenderPassEncoderInsertDebugMarker(m_raw, markerLabel);
}
void RenderPassEncoder::popDebugGroup() {
  return wgpuRenderPassEncoderPopDebugGroup(m_raw, );
}
void RenderPassEncoder::pushDebugGroup(char const * groupLabel) {
  return wgpuRenderPassEncoderPushDebugGroup(m_raw, groupLabel);
}
void RenderPassEncoder::setBindGroup(uint32_t groupIndex, const BindGroup& group, uint32_t dynamicOffsetCount, uint32_t const * dynamicOffsets) {
  return wgpuRenderPassEncoderSetBindGroup(m_raw, groupIndex, group, dynamicOffsetCount, dynamicOffsets);
}
void RenderPassEncoder::setBlendConstant(Color const * color) {
  return wgpuRenderPassEncoderSetBlendConstant(m_raw, color);
}
void RenderPassEncoder::setIndexBuffer(const Buffer& buffer, IndexFormat format, uint64_t offset, uint64_t size) {
  return wgpuRenderPassEncoderSetIndexBuffer(m_raw, buffer, format, offset, size);
}
void RenderPassEncoder::setLabel(char const * label) {
  return wgpuRenderPassEncoderSetLabel(m_raw, label);
}
void RenderPassEncoder::setPipeline(const RenderPipeline& pipeline) {
  return wgpuRenderPassEncoderSetPipeline(m_raw, pipeline);
}
void RenderPassEncoder::setScissorRect(uint32_t x, uint32_t y, uint32_t width, uint32_t height) {
  return wgpuRenderPassEncoderSetScissorRect(m_raw, x, y, width, height);
}
void RenderPassEncoder::setStencilReference(uint32_t reference) {
  return wgpuRenderPassEncoderSetStencilReference(m_raw, reference);
}
void RenderPassEncoder::setVertexBuffer(uint32_t slot, const Buffer& buffer, uint64_t offset, uint64_t size) {
  return wgpuRenderPassEncoderSetVertexBuffer(m_raw, slot, buffer, offset, size);
}
void RenderPassEncoder::setViewport(float x, float y, float width, float height, float minDepth, float maxDepth) {
  return wgpuRenderPassEncoderSetViewport(m_raw, x, y, width, height, minDepth, maxDepth);
}


// Methods of RenderPipeline
BindGroupLayout RenderPipeline::getBindGroupLayout(uint32_t groupIndex) {
  return wgpuRenderPipelineGetBindGroupLayout(m_raw, groupIndex);
}
void RenderPipeline::setLabel(char const * label) {
  return wgpuRenderPipelineSetLabel(m_raw, label);
}


// Methods of Sampler
void Sampler::setLabel(char const * label) {
  return wgpuSamplerSetLabel(m_raw, label);
}


// Methods of ShaderModule
void ShaderModule::getCompilationInfo(CompilationInfoCallback callback, void * userdata) {
  return wgpuShaderModuleGetCompilationInfo(m_raw, callback, userdata);
}
void ShaderModule::setLabel(char const * label) {
  return wgpuShaderModuleSetLabel(m_raw, label);
}


// Methods of Surface
TextureFormat Surface::getPreferredFormat(const Adapter& adapter) {
  return wgpuSurfaceGetPreferredFormat(m_raw, adapter);
}


// Methods of SwapChain
TextureView SwapChain::getCurrentTextureView() {
  return wgpuSwapChainGetCurrentTextureView(m_raw, );
}
void SwapChain::present() {
  return wgpuSwapChainPresent(m_raw, );
}


// Methods of Texture
TextureView Texture::createView(TextureViewDescriptor const * descriptor = nullptr) {
  return wgpuTextureCreateView(m_raw, descriptor);
}
void Texture::destroy() {
  return wgpuTextureDestroy(m_raw, );
}
uint32_t Texture::getDepthOrArrayLayers() {
  return wgpuTextureGetDepthOrArrayLayers(m_raw, );
}
TextureDimension Texture::getDimension() {
  return wgpuTextureGetDimension(m_raw, );
}
TextureFormat Texture::getFormat() {
  return wgpuTextureGetFormat(m_raw, );
}
uint32_t Texture::getHeight() {
  return wgpuTextureGetHeight(m_raw, );
}
uint32_t Texture::getMipLevelCount() {
  return wgpuTextureGetMipLevelCount(m_raw, );
}
uint32_t Texture::getSampleCount() {
  return wgpuTextureGetSampleCount(m_raw, );
}
TextureUsage Texture::getUsage() {
  return wgpuTextureGetUsage(m_raw, );
}
uint32_t Texture::getWidth() {
  return wgpuTextureGetWidth(m_raw, );
}
void Texture::setLabel(char const * label) {
  return wgpuTextureSetLabel(m_raw, label);
}
void Texture::viewSetLabel(char const * label) {
  return wgpuTextureViewSetLabel(m_raw, label);
}


// Methods of TextureView
void TextureView::setLabel(char const * label) {
  return wgpuTextureViewSetLabel(m_raw, label);
}



#endif // WEBGPU_CPP_IMPLEMENTATION


} // namespace wgpu
